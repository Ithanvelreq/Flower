import os
import numpy as np
import soundfile as sf
from torch.utils.data import Dataset
from utils import perc_types


def get_class_nr_from_fn(fn):
    for i, (perc_tp, keywords) in enumerate(perc_types.items()):
        for k in keywords:
            if k in os.path.basename(fn):
                return i

    return None


def filter_fns(fns, filter):
    fns_filtered = []
    for fn in fns:
        if filter(fn):
            fns_filtered.append(fn)
    return fns_filtered


def get_from_group(group_nr, groups_mix, groups_single, nr_samples,
                   min_mix_nr=1, normalize=True, rm_single_from_mix=True):
    to_mix_fns = groups_mix[group_nr].copy()

    if groups_single is not None and rm_single_from_mix:
        to_select_fns = groups_single[group_nr].copy()
        rand1 = np.random.randint(len(to_select_fns))
        selected_fn = to_select_fns[rand1]
        to_mix_fns = remove_single_from_mix(selected_fn, to_mix_fns)

    nr_to_mix = np.random.randint(min_mix_nr, len(to_mix_fns) + 1)
    np.random.shuffle(to_mix_fns)
    to_mix_fns = to_mix_fns[:nr_to_mix]
    mix = (create_mix(nr_samples, to_mix_fns))

    if groups_single is not None:
        sample = get_fragment_from_file(selected_fn, nr_samples, normalize)
    else:
        return np.cast['float32'](mix)

    return np.cast['float32'](mix), np.cast['float32'](sample)


def get_fragment_from_file(fn, nr_samples, normalize=False, from_=0):
    sample = None
    with sf.SoundFile(fn, 'r') as f:
        assert f.samplerate == 44100, f"sample rate is {f.samplerate}, should be 44100 though."
        try:
            nr_samples_ = np.minimum(nr_samples, f.frames)
            f.seek(from_)
            sample = f.read(nr_samples_)
            if len(sample.shape) > 1 and sample.shape[1] == 2:
                sample = sample.mean(1)

            # sample too short -> pad
            if len(sample) < nr_samples:
                sample_ = np.zeros((nr_samples,))
                sample_[:len(sample)] = sample
                sample = sample_

            if normalize:
                sample = normalize_signal(sample)
        except Exception as e:
            pass
    return sample


def create_mix(nr_samples, to_mix_fns, normalize=True, from_=-1):
    mix = np.zeros((nr_samples,))

    if from_ < 0:
        with sf.SoundFile(to_mix_fns[0], 'r') as f:
            if f.frames - nr_samples - 1 < 0:
                from_ = 0
            else:
                from_ = np.random.randint(f.frames - nr_samples - 1)

    for fn in to_mix_fns:
        sample = get_fragment_from_file(fn, nr_samples, from_=from_)
        if sample is not None:
            try:
                mix[:sample.shape[0]] += sample
            except ValueError as e:
                raise e

    if normalize:
        mix = normalize_signal(mix)
    else:
        mix /= len(to_mix_fns)

    return mix


def normalize_signal(mix):
    max_abs = np.maximum(np.abs(np.min(mix)), np.max(mix))
    if max_abs > 0:
        mix /= max_abs
    return mix


def remove_single_from_mix(single, mix):
    remove_from_mix = os.path.basename(single).split("_wav")[0] + ".wav"
    to_mix_fns = []
    for fn in mix:
        if os.path.basename(fn) != remove_from_mix:
            to_mix_fns.append(fn)
    return to_mix_fns


def prepare_fn_groups(root_folder, filter_fun_level1=None,
                      filter_fun_level2=None, frag_folder="fragments"):
    # Assumes folders with stems and subfolder "fragments" in each folder
    # containing short fragments of stems (e.g., percussion samples)
    # generated by extract_samples.py
    if filter_fun_level1 == None:
        filter_fun_level1 = lambda x: True

    if filter_fun_level2 == None:
        filter_fun_level2 = lambda x: True

    result = []
    for root0, dirs0, _ in os.walk(root_folder):
        for dir0 in dirs0:
            fns_level1 = []
            fns_level2 = []
            for root1, dirs1, files1 in os.walk(os.path.join(root0, dir0)):
                for file1 in files1:
                    if root1.endswith(frag_folder):
                        if filter_fun_level2(os.path.join(root1, file1)):
                            fns_level2.append(os.path.join(root1, file1))
                    else:
                        if filter_fun_level1(os.path.join(root1, file1)):
                            fns_level1.append(os.path.join(root1, file1))

            if len(fns_level1) > 0 and len(fns_level2) > 0:
                result.append([fns_level1, fns_level2])

    return result


class ContrastLoader(Dataset):
    def __init__(self, groups_mix, groups_single, nr_samples, normalize=True,
                 min_mix_nr=1):
        self.groups_mix = groups_mix
        self.groups_single = groups_single
        self.nr_samples = nr_samples
        self.normalize = normalize
        self.min_mix_nr = min_mix_nr

    def __len__(self):
        return len(self.groups_mix)

    def __getitem__(self, item):
        return get_from_group(item, self.groups_mix, self.groups_single,
                              self.nr_samples, self.min_mix_nr, self.normalize)


class SingleLoader(Dataset):
    def __init__(self, fns, nr_samples, normalize=True):
        self.fns = fns
        self.nr_samples = nr_samples
        self.normalize = normalize

    def __len__(self):
        return len(self.fns)

    def __getitem__(self, item):
        frag = get_fragment_from_file(self.fns[item],
                                      nr_samples=self.nr_samples,
                                      normalize=True)
        return np.cast['float32'](frag), self.fns[item]


class ClassifyLoader(Dataset):
    def __init__(self, fns, nr_samples, normalize=True):
        self.fns = fns
        self.nr_samples = nr_samples
        self.normalize = normalize

    def __len__(self):
        return len(self.fns)

    def __getitem__(self, item):
        frag = get_fragment_from_file(self.fns[item],
                                      nr_samples=self.nr_samples,
                                      normalize=True)
        class_nr = get_class_nr_from_fn(self.fns[item])
        #assert class_nr is not None, f"No valid class found in filname: {self.fns[item]}"
        if class_nr is None:
            class_nr = len(perc_types.keys())
        class_array = np.zeros((len(perc_types.keys())+1,))
        class_array[class_nr] = 1
        return np.cast['float32'](frag), np.cast['float32'](class_array)